package dev._2lstudios.exploitfixer.bukkit.listener;

import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;

import dev._2lstudios.exploitfixer.bukkit.managers.ModuleManager;
import dev._2lstudios.exploitfixer.bukkit.utils.ExploitUtil;
import dev._2lstudios.exploitfixer.shared.modules.PacketsModule;
import dev._2lstudios.hamsterapi.events.PacketDecodeEvent;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import io.netty.buffer.ByteBuf;

public class PacketDecodeListener implements Listener {
    private final ExploitUtil exploitUtil;
    private final PacketsModule packetsModule;

    PacketDecodeListener(final ExploitUtil exploitUtil, final ModuleManager moduleManager) {
        this.exploitUtil = exploitUtil;
        this.packetsModule = moduleManager.getPacketsModule();
    }

    private String getName(final Player player) {
        if (player == null) {
            return "unknown";
        } else {
            return player.getName();
        }
    }

    private void onPacketDecode(final Cancellable event, final HamsterPlayer hamsterPlayer, final Player player,
            final ByteBuf byteBuf) {
        if (player != null && player.isOnline()) {
            final String playerName = player.getName();
            final int dataBytes = packetsModule.getDataBytes();
            final int refCnt = byteBuf.refCnt();
            final int capacity = byteBuf.capacity();
            final int readableBytes = byteBuf.readableBytes();

            if (capacity < 0) {
                final double dataVls = packetsModule.getDataVls();
                final String reason = "[Decoder|Data] " + playerName
                        + " sent a packet with invalid capacity! capacity: " + capacity + " Vls: " + dataVls;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
            } else if (refCnt < 1) {
                final double dataVls = packetsModule.getDataVls();
                final String reason = "[Decoder|Data] " + playerName + " sent a packet with invalid refCnt! refCnt: "
                        + refCnt + " Vls: " + dataVls;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
            } else {
                final double dataVls = packetsModule.getDataVls();
                String reason = null;

                if (capacity > dataBytes) {
                    reason = "[Decoder|Data] " + playerName + " sent a packet that exceeds capacity bytes limit! " + capacity
                            + "/" + dataBytes + " Vls: " + dataVls;
                } else if (readableBytes > dataBytes) {
                    reason = "[Decoder|Data] " + playerName + " sent a packet that exceeds readable bytes limit! " + readableBytes
                            + "/" + dataBytes + " Vls: " + dataVls;
                }

                if (reason != null) {
                    exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls);
                }
            }
        } else if (packetsModule.isOffline()) {
            final String reason = "[Decoder|Offline] " + getName(player) + " sent a packet while offline!";

            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, 0);
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    public void onPacketDecode(final PacketDecodeEvent event) {
        if (!packetsModule.isEnabled()) {
            return;
        }

        final HamsterPlayer hamsterPlayer = event.getHamsterPlayer();

        onPacketDecode(event, hamsterPlayer, hamsterPlayer.getPlayer(), event.getByteBuf().get());
    }
}
